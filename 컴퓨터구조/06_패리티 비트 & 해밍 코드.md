# 패리티 비트 & 해밍 코드

## 패리티 비트

> 정보 전달 과정에서 오류가 생겼는 지 검사하기 위해 추가하는 비트를 말한다.
>
> 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송한다.



**종류** : 짝수, 홀수

전체 비트에서 (짝수, 홀수)에 맞도록 비트를 정하는 것



***짝수 패리티일 때 7비트 데이터가 1010001라면?***

> 1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야 함
>
> 답 : 11010001 (맨앞이 패리티비트)





## 해밍 코드

> 데이터 전송 시 1비트의 에러를 정정할 수 있는 자기 오류정정 코드를 말한다.
>
> 패리티비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있다. (패리티 비트는 오류를 검출하기만 할 뿐 수정하지는 않기 때문에 해밍 코드를 활용)



### 방법

2의 n승 번째 자리인 1,2,4번째 자릿수가 패리티 비트라는 것으로 부터 시작한다. 이 숫자로부터 시작하는 세개의 패리티 비트가 짝수인지, 홀수인지 기준으로 판별한다.

n번째 패리티 비트는 n개의 비트를 검사하고, 다시 n개를 건너뛰고, 다시 n개를 또 검사하고, n개 건너뛰는 것을 반복하는 비트를 대상으로 한다.

<img src="06_패리티 비트 & 해밍 코드.assets/image-20220424161058727.png">

> 1. p1 패리티 비트: p1부터 시작해서 한 개씩 보고 건너뛰는 것을 반복했면서 만나는 모든 d비트
> 2. p2 패리티 비트: p2부터 시작해서 두 개씩 보고 건너뛰는 것을 반복하면서 만나는 모든 d비트
> 3. ......



***짝수 패리티의 해밍 코드가 0011011일때 오류가 수정된 코드는?***

1. 1, 3, 5, 7번째 비트 확인 : 0101로 짝수이므로 '0'
2. 2, 3, 6, 7번째 비트 확인 : 0111로 홀수이므로 '1'
3. 4, 5, 6, 7번째 비트 확인 : 1011로 홀수이므로 '1'

> 1, 3, 5, 7 / 2, 3, 6, 7 / 4, 5, 6, 7이라고만 쓰면 일관성이 잘 보이지 않을 수 있지만, 헷갈린다면 위의 생성 규칙 표를 참고.



역순으로 패리티 비트 '110'을 도출했다. 10진법으로 바꾸면 '6'으로, 6번째 비트를 수정하면 된다.

따라서 **정답은 00110'0'1**이다.

---

### 위는 예시가 좀 이상합니다. 아래의 다른 예시를 참고합시다.



***짝수 패리티 수신어로 011100101110을 받았다. 오류가 있는지 보고 검출하여 수정해보자.***

위 패리티 비트 생성 규칙대로라면

| p01  | p02  | d03  | p04  | d05  | d06  | d07  | p08  | d09  | d10  | d11  | d12  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  1   |  1   |  0   |  0   |  1   |  0   |  1   |  1   |  1   |  0   |

1. p1 검사 (하나 보고 하나 건너뛰는 데이터 비트 = 3, 5 ,7, 9, 11)

   p1: 0 => 1 0 1 1 1 ==> 맞는 패리티 비트

2. p2 검사 (패리티 비트에서 시작해서 둘 보고 둘 건너뜀 = 3, 6, 7, 10, 11)

   p2: 1 => 1 0 1 1 1 ==> 틀린 패리티 비트 ==> **p2 오류**

3. p4 검사 (5, 6, 7, 12)

   p4: 1 => 0 0 1 0 ==> 맞는 패리티 비트

4. p8 검사 (9, 10, 11, 12)

   p8: 0 => 1 1 1 0 ==> 틀린 패리티 비트 ==> **p8 오류**

위와 같은 검사 결과에서 p2, p8의 값이 잘못되었고, 2 + 8인 10번째 비트, 즉 d10에서 오류가 발생한 것을 검출할 수 있다.

따라서 이 예시에서 옳게 수정된 수신어는 **011100101010**이다.