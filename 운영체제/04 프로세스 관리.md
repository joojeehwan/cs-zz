## 프로세스 관리



### 프로세스와 관련한 시스템 콜

|        |                                        |
| ------ | -------------------------------------- |
| fork() | create a child(copy)                   |
| exec() | overlay new image                      |
| wait() | sleep until child is done              |
| exit() | frees all the resources, notify parent |



### 프로세스 생성(Process Creation)

*  부모 프로세스(Parent process)가 자식 프로세스(children process) 생성
*  프로세스의 트리(계층 구조) 형성
*  프로세스는 자원을 필요로 함
   *  운영체제로부터 받음
   *  부모와 공유
*  자원의 공유
   *  부모와 자식이 모든 자원을 공유하는 모델
   *  일부를 공유하는 모델
   *  전혀 공유하지 않는 모델
*  수행(Execution)
   *  부모와 자식은 공존하며 수행되는 모델
   *  자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델
*  주소 공간(Address space)
   *  자식은 부모의 공간을 복사함(binary and OS data)
   *  자식은 그 공간에 새로운 프로그램을 올림
*  유닉스의 예
   *  `fork ()` 시스템 콜이 새로운 프로세스를 생성
      *  부모를 그대로 복사(OS data except PID + binary)
      *  주소 공간할당
   *  fork 다음에 이어지는` exec () `시스템 콜을 통해 새로운 프로그램을 메모리에 올림

```text
보통 복제생성을 함(나중에)
부모 프로세스는 하나 자식은 여러개 트리처럼 생겼겠지
프로세스가 실행되려면 자원이 있어야겟지 cpu, 메모리 등
자원은 보통 운영체제로부터 받음 부모와 공유할수도 안할수도 있음
원칙적으로는 공유를 하진 않음 왜냐면 사실 별도의 프로세스이기 때문에 경쟁하는 사이가 됨 cpu를 메모리를 얻기 위해 경쟁 그래서 보통 공유하지 X 모델이 대부분임
부모가 기다리는 wait = blocked 상태

주소공간
주소공간을 복사함 pcb라던지 자원이던지
일단 복사한 곳에 새로운 프로그램을 덮어씌움
복제생성을 fork 라는 시스템 콜의 역할을 함
복제생성을 하고 덮어씌우는 것이 exec이라는 시스템 콜
즉 fork > exec 를 실행
자식을 만들지 않고 exec을 해버리면 완전 새로운 프로세스로 바뀌게되겟지
시스템콜이잖아 운영체제한테 자식낳아줘! 해서 운영체제가 해주는거임

리눅스나 일부 모델은 모든 것을 카피하는 게 아니라 일단 공유할 수 있는 건 공유하고 카피
그러다가 부모랑 자식 내용이 달라질 수 잇겟지 어쨋든 별개의 프로세스니까
결국 각자의 길을 가게되겠지 그때 필요한 부분을 복사해서 갖게 되겠지
그걸 Copy-on-write(COW) 라고 부름
write가 발생했을 대 copy를 하겠다는 뜻
write = 원래 있던 내용이 바뀜 그 이전까지는 계속 부모꺼를 공유하다가
내용이 수정되면 부모의 code, data, stack을 카피하겠다 
물리적인 메모리에 잘게 쪼개져서 올라가잇는데 그것중에 필요한것만 가져오겠다는거임(메모리에서 더 자세히 설명)

일단 복제생성 한 경우에 나중에 덮어씌움
우리도 과제할때 템플릿은 그대로 복붙하고 그 담에 하잔아 그말임
```



### 프로세스 종료(Process Termination)

*  프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(`exit`)
   *  자식이 부모에게 output data를 보냄(via wait)
   *  프로세스의 각종 자원들이 운영체제에게 반납됨
*  부모 프로세스가 자식의 수행을 종료시킴(`abort`)
   *  자식이 할당 자원의 한계치를 넘어섰을 경우
   *  자식에게 할당된 태스크가 더 이상 필요하지 않을 경우
   *  부모가 종료(exit)하는 경우
      *  운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다
      *  단계적인 종료

 ```
예를들어 함수가 종료되면 중괄호를 닫을때 프로그램이 exit 콜 하지 않아도 알아서 끝내겠지 exit이라는 건 그런거임
프로세스가 끝날때 자식이 부모한테 data 보냄 wait 시스템 콜을 통해
부모보다 자식이 항상 먼저 죽음
자발적으로 종료될땐 exit 비자발적으론 abort
그럼 어떤 때 강제종료?
자식이 할당 자원한계치를 넘어서서 부모가 강제로 죽임
자식을 낳은 이유가 일 시키려고 한건데 자식이 더이상 할 일이 없다면 자식 종료
어쩌다보니까 부모를 종료해야돼 그러면 자식이 먼저 죽어야하기 때문에 자식을 모두 다 죽임 자식이 자식 낳았을 경우 젤 밑의 자식 먼저 죽이고 위로 죽임
잔인하대 교수님이 잔인하게 설명하시잔아요 ...
 ```



### fork() 시스템콜

![image-20220317060433111](OS.assets/image-20220317060433111.png)



```
실제 운영체제 내부 코드는 아니고 사용자프로그램이 포크 사용해서 프로세스 만드는 코드

fork() 이게 지금 운영체제한테 프로세스 하나 만들어줘! 하는 시스템콜인거임

처음엔 부모 하나 있다가 fork 하면 새로운프로세스 하나 만들어지겠지
그리고 밑에코드 실행
만들어진 자식은 main함수부터 시작하는 것이 아니라 fork 이후 시점부터 코드 실행
부모의 context를 그대로 복사했기 때문에 프로그램 카운터가 거기를 가리키고 있을 거임
문제가 있어 복제를 해놨더니 복제본이 내가 원본이라고 우기는 거야
그렇게되면 아주 혼란스럽겟지 
문제가 또있어 부모랑 똑같은 놈이 만들어지니까 세상에 있는 프로그램들은 모두 똑같은 제어 흐름을 따라가야할거같고 < 뭔말?
그래서 운영체제가 복제를 할 때는 fork를 할 때 자식과 부모를 구분해줌 return value 로 즉 결과값이 다름
부모는 결과값이 양수고 자식은 0임
이렇게 return value가 달라서 다른 일을 할 수 잇겠쥐 if문으로 구분해둔걸 보면 
근데결국엔똑같은거잔아 왜똑같은걸? 그래서 exec이 있음
```



### exec() 시스템 콜

![image-20220317061740245](OS.assets/image-20220317061740245.png)



![image-20220317062248178](OS.assets/image-20220317062248178.png)

```
프로그램을 완전히 새로운 process로
fork를 해서 자식 하나 만들고 부모라면 else문
자식이라면 if우ㅟ에있는ㄷ
execlp는 exec 시스템 콜을 하는 부분
지금 저런 코드를 가진 프로그램을 실행하다가 exec부분 만나면 저런 기억은 완전 잊어버리고 저기에 있는 새로운 프로그램으로 덮어쓰게 되는거이
date라는 새로운 프로그램ㅇㅇ
그래서 한 번 exec하면 다시 처음으로 돌아올 수 없음
사실은 ... 자식을 ㅁ만들어야만 exec을 할 수 있는건 또 아님 ㅡㅡ
그래서 fork를 빼버리고 exec을 할 수도 있다능
그래서 exec 뒤에 있는 코드는 영원히 실행 불가
```

![image-20220317062329794](OS.assets/image-20220317062329794.png)

```
execlp를 할 때는 프로그램 이름 2번 적어주고 arg 적어주고 마지막에 char * 해주면 됨
걍 귳칙임
```



### wait () 시스템 콜

*  프로세스 A가 wait() 시스템 콜을 호출하면
   *  커널은 child가 종료될 때까지 프로세스 A를 sleep시킨다 (block 상태)
   *  Child proccess가 종료되면 커널은 프로세스 A를 깨운다 (ready 상태)

![image-20220317062905722](OS.assets/image-20220317062905722.png)



```
보통 block 상태라는 건 오래걸리는 이벤트를 기다리고 이벤트가 만족되면 cpu를 가질 수 있는 ready상태로 돌아오는 거였지
wait 시스템콜을 하면 자식프로세스가 종료되기를 기다리면서 block상태가 되고 자식이 끝나면 block에서 ready가 됨
그림참고

지금 코드에서 부모코드쪽에 wait시스템콜을 넣어놨잖아 그럼 cpu를 얻지 못하고 그냥 기다리게 됨 자식 프로세스가 종료될때까지 자식 프로세스가 종료되면 wait를 바져나가고 다음 코드를 실행하게 됨 자식이 종료될 때까지 기다리는 시스템 콜!
자식이랑 cpu를 먼저 잡을라고 경쟁하는 모델이 있고 자식이 종료될 때까지 기다리는 모델이 있는데 wait를 하면 기다리는 두번째 모델에 해당
대표적인 예가
리눅스에서 프로그램 A를 실행시키고 엔터를 치면 프로그램이 종료되고
커맨드라인이 새로 뜨잔아
이게 그거라네 흐응....
프로그램을 입력하고 엔터를 치면 그 프로그램은 지금 입력받은 shell의 자식프로세스 형태로 생성되고 자식이 실행되는 동안 shell을 띄운 프로그램은 wait시스템 콜을 해서 기다림 자식이 완료될 때까지 자식이 끝나면 다시 커맨드라인이 뜨고 새로운 무언가를 입력받을 수 있게 되는거지...
그렇다네요
```



### exit() 시스템 콜

*  프로세스의 종료
   *  자발적 종료
      *  마지막 statement 수행 후 exit() 시스템 코을 통해 프로그램에 명시적으로 ㅈ거어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌
   *  비자발적 종료
      *  부모 프로세스가 자식 프로세스를 강제 종료시킴
         *  자식 프로세스가 한계치를 넘어서는 자원 요청
         *  자식에게 할당된 태스크가 더 이상 필요하지 않음
      *  키보드로 kill, break 등을 친 경우
      *  부모가 종료하는 경우
         *  부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨



### 프로세스 간 협력

*  독립적 프로세스(Independent process)
   *  프로세스는 각자의 주소 공간을 가지로 수행되므로 원칙적으로 하나의 프로세스는 다르 프로세스의 수행에 영향을 미치지 못함
*  협력 프로세스(Cooperatin process)
   *  프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에  영향을 미칠 수 있음
*  프로세스 간 협력 메커니즘(IPC: Interprocess Communication)
   *  메시지를 전달하는 방법
      *  message passing : 커널을 통해 메시지 전달
   *  주소 공간을 공유하는 방법
      *  shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음
      *  thread: thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능

![image-20220318090821770](OS.assets/image-20220318090821770.png)



```
프로세스는 독립적임 pcb도 각자 갖고 결국엔 각자 프로세스이기 때문에
경우에 따라선 협력을 해야 효율적으로 실행되는 때가 있을거임
그래서 협력 메커니즘이 존재함 IPC
크게 두가지 방법이 있음

shared memory 랑 message passing
메시지 패싱은 프로세스 A가 B한테 정보 전달하고 그걸로 실행하고 이런거
서로 메시지를 주고받음
근데 프로세스는 원래 독립적임 자신의 메모리 주소공간만 볼 수 있고 또 다른 프로세스한테 메시지 전달하는 방법도 원래는 없음 그래서 커널을 통해서 전달을 해줌

메시지 패싱 (밑에)

shared memory는 일부 주소공간을 두 프로세스가 공유함 그림은 물리적인 메모리를 그려놓은 것
shared memory를 하려면 커널한테 shared memory 쓰겠다고 시스템 콜 해서 매핑 해놓고 share 하게 해놓은 다음에 프로세스끼리 공유
처음엔 커널의 도움을 받고 다음은 사용자프로그램끼리 shared memory 쓰는거
두 프로세스는 상당히 신뢰할 수 있을 만한 프로그램이어야함

thread는
프로세스 하나에 cpu 수행 단위가 여러개 있느거지 그래서 사실 협력은 아님 그러나 thread끼리는 주소공간을 완전히 공유하고 있어서 협력?이 쉽겟지
그래서 인제 스레드 간의 협력 참고해라~
```



### Message Passing



#### Message system

프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템

*  ##### Direct Communication

통신하려는 프로세스의 이름을 명시적으로 표시

![image-20220318090225304](OS.assets/image-20220318090225304.png)



*  ##### Indirect Communication

mailbox(또는 port)를 통해 메시지를 간접 전달

![image-20220318090553490](OS.assets/image-20220318090553490.png)



```
둘다 프로세스 대 프로세스로 전달하는 건 불가능해서 중간에 운영체제 커널을 통해서
메시지를 전달함 다만 인터페이스 측면에서 다이렉트는 전달하는 내용과 누구한테 전달할지를 명시하고 누구한테 받았는지도 나옴
인다이렉트는 누구한테 전달할지를 정해두지 않고 그냥 메일박스에 넣어둠 그러면 누가 꺼내볼지 명시를 안했으니까 아무나 가져갈 수 있음 뭐임..
```

